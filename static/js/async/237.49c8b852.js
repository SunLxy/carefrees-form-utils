"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([["237"],{6497:function(e,n,a){a.r(n),a.d(n,{default:()=>h});var s=a(4246),t=a(980);function r(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",strong:"strong",pre:"pre"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"工具方法",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#工具方法",children:"#"}),"工具方法"]}),"\n",(0,s.jsxs)(n.p,{children:["从",(0,s.jsx)(n.a,{href:"https://www.lodashjs.com/",rel:"noopener noreferrer",target:"_blank",children:(0,s.jsx)(n.code,{children:"lodash"})}),"中搬了部分需要的代码块"]}),"\n",(0,s.jsxs)(n.h2,{id:"get",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#get",children:"#"}),"get"]}),"\n",(0,s.jsx)(n.p,{children:"根据 object对象的path路径获取值。 如果解析 value 是 undefined 会以 defaultValue 取代。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"类型"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export declare const get: (object: Object, path: PropertyPath, defaultValue?: any) => any;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"案例"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const object = { 'a': [{ 'b': { 'c': 3 } }] };\n \nget(object, 'a[0].b.c');\n// => 3\n \nget(object, ['a', '0', 'b', 'c']);\n// => 3\n \nget(object, 'a.b.c', 'default');\n// => 'default'\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"set",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#set",children:"#"}),"set"]}),"\n",(0,s.jsx)(n.p,{children:"设置 object对象中对应 path 属性路径上的值，如果path不存在，则创建。 缺少的索引属性会创建为数组，而缺少的属性会创建为对象"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"类型"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export declare function set<T = any>(object: T, path: PropertyPath, value: any): T;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"案例"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const object = { 'a': [{ 'b': { 'c': 3 } }] };\n \nset(object, 'a[0].b.c', 4);\nconsole.log(object.a[0].b.c);\n// => 4\n \nset(object, ['x', '0', 'y', 'z'], 5);\nconsole.log(object.x[0].y.z);\n// => 5\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"has",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#has",children:"#"}),"has"]}),"\n",(0,s.jsx)(n.p,{children:"检查 path 是否是object对象的直接属性。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"类型"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export declare function has<T = any>(object: T, key: string | number): boolean;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"案例"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const object = { 'a': { 'b': 2 } };\n \nhas(object, 'a');\n// => true\n \nhas(object, 'a.b');\n// => true\n \nhas(object, ['a', 'b']);\n// => true\n \n"})}),"\n",(0,s.jsxs)(n.h2,{id:"clonebynamepathlist",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#clonebynamepathlist",children:"#"}),"cloneByNamePathList"]}),"\n",(0,s.jsx)(n.p,{children:"获取object对象中对应 path 属性路径上的值，如果path不存在，则创建。 缺少的索引属性会创建为数组，而缺少的属性会创建为对象"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"类型"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export declare function cloneByNamePathList(store: Record<string, any>, namePathList: PropertyName[]): Record<string, any>;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"案例"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'const namePathList =["name","age","address","phone"]\nconst object = { name: "张三", age: 18, address: "北京" };\ncloneByNamePathList(object, namePathList);\n// => { name: "张三", age: 18, address: "北京", phone: undefined }\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"基础类型",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#基础类型",children:"#"}),"基础类型"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export type Many<T> = T | readonly T[];\nexport type PropertyName = string | number | symbol | undefined;\nexport type PropertyPath = Many<PropertyName>;\n"})})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(r,e)})):r(e)}let h=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["core%2Futils.md"]={toc:[{id:"get",text:"get",depth:2},{id:"set",text:"set",depth:2},{id:"has",text:"has",depth:2},{id:"clonebynamepathlist",text:"cloneByNamePathList",depth:2},{id:"基础类型",text:"基础类型",depth:2}],title:"工具方法",headingTitle:"工具方法",frontmatter:{}}}}]);